// Generated by CoffeeScript 1.8.0
var Attack, AttackDefinition, Environment, GameLoop, Loop, MainMenuLoop, Piece, Player, Sprite, Stage, animateAsCPU, animateAsP1, attacks, constants, loadImage, loadPlayer, loadSound, loadStage, pieces, playSound, players, rectCollide, stages,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

constants = {
  "UI_RECT": {
    "x": 0,
    "y": 0,
    "w": 800,
    "h": 40
  },
  "MENU_BUTTONS_POS": {
    "x": 100,
    "y": 100
  },
  "MENU_BUTTONS_WIDTH": 100,
  "MENU_BUTTONS_HEIGHT": 200,
  "MENU_BUTTON_HEIGHT": 50,
  "MENU_NUM_ELEM": 4,
  "KEY_ENTER": 13,
  "KEY_ESC": 27,
  "KEY_LEFT": 37,
  "KEY_UP": 38,
  "KEY_RIGHT": 39,
  "KEY_DOWN": 40,
  "BUTTON_GRAB": 65,
  "BUTTON_LOW_KICK": 67,
  "BUTTON_MED_PUNCH": 68,
  "BUTTON_HIGH_PUNCH": 83,
  "BUTTON_MED_KICK": 88,
  "BUTTON_BLOCK": 90,
  "P1_INIT_POS": {
    "x": 100,
    "y": 0
  },
  "P2_INIT_POS": {
    "x": 700,
    "y": 0
  },
  "GRAVITY": 1.3,
  "LIMIT_LEFT": 50,
  "LIMIT_RIGHT": 50
};

stages = [
  {
    "background_img": "src/images/stages/0_b.png",
    "background_height": 450,
    "background_frames": 1,
    "foreground_img": "src/images/stages/0_f.png",
    "foreground_height": 125,
    "foreground_frames": 2,
    "foreground_loc": 325,
    "base_line": 405,
    "width": 800
  }
];

players = [
  {
    "name": "Ducky",
    "legs": 0,
    "body": 1,
    "head": 2,
    "arms": 3,
    "attacks": {
      "high_punch": 3,
      "medium_punch": 3,
      "high_kick": 3,
      "medium_kick": 3,
      "special_punch_1": 3,
      "special_punch_2": 3,
      "special_kick_1": 3,
      "special_kick_2": 3
    }
  }
];

pieces = [
  {
    "class": "piece",
    "attributes": {
      "type": "leg",
      "name": "Basic Legs",
      "movement": 5.0,
      "jump": 30.0,
      "weight": 5.0,
      "max_weight": 30.0,
      "power": 1.0,
      "base_points": [
        [
          {
            "x": 40,
            "y": 10
          }, {
            "x": 40,
            "y": 10
          }
        ], [
          {
            "x": 40,
            "y": 10
          }, {
            "x": 40,
            "y": 10
          }
        ], [
          {
            "x": 0,
            "y": 0
          }, {
            "x": 40,
            "y": 0
          }
        ], [
          {
            "x": 40,
            "y": 10
          }, {
            "x": 40,
            "y": 10
          }
        ], [
          {
            "x": 40,
            "y": 10
          }, {
            "x": 40,
            "y": 10
          }
        ]
      ],
      "attack_start_frame": [0],
      "attack_base_points": [
        [
          {
            "x": 0,
            "y": 0
          }, {
            "x": 0,
            "y": 0
          }
        ]
      ]
    },
    "image": "src/images/pieces/0.png",
    "dimensions": [
      {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 40
      }, {
        "w": 40,
        "h": 40
      }, {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }
    ],
    "frames": [2, 1, 1, 1, 1]
  }, {
    "class": "piece",
    "attributes": {
      "type": "body",
      "name": "Basic Body",
      "weight": 5.0,
      "defense": 1.0,
      "special_defense": 1.0,
      "hit_points": 100.0,
      "legs_points": [
        [
          {
            "x": 30,
            "y": 60
          }, {
            "x": 50,
            "y": 60
          }
        ], [
          {
            "x": 30,
            "y": 60
          }, {
            "x": 50,
            "y": 60
          }
        ], [
          {
            "x": 30,
            "y": 60
          }, {
            "x": 50,
            "y": 60
          }
        ], [
          {
            "x": 30,
            "y": 60
          }, {
            "x": 50,
            "y": 60
          }
        ], [
          {
            "x": 30,
            "y": 60
          }, {
            "x": 50,
            "y": 60
          }
        ]
      ],
      "head_points": [
        [
          {
            "x": 40,
            "y": 20
          }, {
            "x": 40,
            "y": 20
          }
        ], [
          {
            "x": 40,
            "y": 20
          }, {
            "x": 40,
            "y": 20
          }
        ], [
          {
            "x": 40,
            "y": 20
          }, {
            "x": 40,
            "y": 20
          }
        ], [
          {
            "x": 40,
            "y": 20
          }, {
            "x": 40,
            "y": 20
          }
        ], [
          {
            "x": 40,
            "y": 20
          }, {
            "x": 40,
            "y": 20
          }
        ]
      ],
      "arms_points": [
        [
          {
            "x": 50,
            "y": 30
          }, {
            "x": 30,
            "y": 30
          }
        ], [
          {
            "x": 50,
            "y": 30
          }, {
            "x": 30,
            "y": 30
          }
        ], [
          {
            "x": 50,
            "y": 30
          }, {
            "x": 30,
            "y": 30
          }
        ], [
          {
            "x": 50,
            "y": 30
          }, {
            "x": 30,
            "y": 30
          }
        ], [
          {
            "x": 50,
            "y": 30
          }, {
            "x": 30,
            "y": 30
          }
        ]
      ]
    },
    "image": "src/images/pieces/1.png",
    "dimensions": [
      {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }
    ],
    "frames": [1, 1, 1, 1, 1]
  }, {
    "class": "piece",
    "attributes": {
      "type": "head",
      "name": "Basic Head",
      "weight": 3.0,
      "special_power": 1.0,
      "base_points": [
        [
          {
            "x": 30,
            "y": 80
          }, {
            "x": 50,
            "y": 80
          }
        ], [
          {
            "x": 30,
            "y": 80
          }, {
            "x": 50,
            "y": 80
          }
        ], [
          {
            "x": 30,
            "y": 80
          }, {
            "x": 50,
            "y": 80
          }
        ], [
          {
            "x": 30,
            "y": 80
          }, {
            "x": 50,
            "y": 80
          }
        ], [
          {
            "x": 30,
            "y": 80
          }, {
            "x": 50,
            "y": 80
          }
        ]
      ]
    },
    "image": "src/images/pieces/2.png",
    "dimensions": [
      {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }
    ],
    "frames": [1, 1, 1, 1, 1]
  }, {
    "class": "piece",
    "attributes": {
      "type": "arm",
      "name": "Basic Arm",
      "weight": 5.0,
      "power": 5.0,
      "defense": 1.0,
      "base_points": [
        [
          {
            "x": 0,
            "y": 40
          }, {
            "x": 80,
            "y": 40
          }
        ], [
          {
            "x": 0,
            "y": 40
          }, {
            "x": 80,
            "y": 40
          }
        ], [
          {
            "x": 0,
            "y": 40
          }, {
            "x": 80,
            "y": 40
          }
        ], [
          {
            "x": 0,
            "y": 40
          }, {
            "x": 80,
            "y": 40
          }
        ], [
          {
            "x": 0,
            "y": 40
          }, {
            "x": 80,
            "y": 40
          }
        ]
      ],
      "attack_start_frame": [0],
      "attack_base_points": [
        [
          {
            "x": 0,
            "y": 0
          }, {
            "x": 0,
            "y": 0
          }
        ]
      ]
    },
    "image": "src/images/pieces/3.png",
    "dimensions": [
      {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }
    ],
    "frames": [1, 1, 1, 1, 1]
  }
];

attacks = [
  {
    "class": "attack",
    "image": "src/images/attacks/0.png",
    "behaviour": "static",
    "type": "normal",
    "multiplier": 1.0,
    "base_points": [
      {
        "x": 0,
        "y": 0
      }, {
        "x": 0,
        "y": 0
      }, {
        "x": 0,
        "y": 0
      }
    ],
    "dimensions": [
      {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }
    ],
    "frames": [3, 3, 3]
  }, {
    "class": "attack",
    "image": "src/images/attacks/0.png",
    "behaviour": "forward",
    "type": "special",
    "multiplier": 1.0,
    "base_points": [
      {
        "x": 0,
        "y": 0
      }, {
        "x": 0,
        "y": 0
      }, {
        "x": 0,
        "y": 0
      }
    ],
    "dimensions": [
      {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }
    ],
    "frames": [3, 3, 3]
  }, {
    "class": "attack",
    "image": "src/images/attacks/0.png",
    "behaviour": "up",
    "type": "mixed",
    "multiplier": 1.0,
    "base_points": [
      {
        "x": 0,
        "y": 0
      }, {
        "x": 0,
        "y": 0
      }, {
        "x": 0,
        "y": 0
      }
    ],
    "dimensions": [
      {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }, {
        "w": 80,
        "h": 80
      }
    ],
    "frames": [3, 3, 3]
  }, {
    "class": "attack",
    "image": "src/images/attacks/0.png",
    "behaviour": "static",
    "type": "normal",
    "multiplier": 1.0,
    "base_points": [
      [
        {
          "x": 20,
          "y": 20
        }, {
          "x": 20,
          "y": 20
        }
      ]
    ],
    "dimensions": [
      {
        "w": 40,
        "h": 40
      }
    ],
    "frames": [3]
  }
];

loadSound = function(environment, src) {
  var request, result;
  result = {
    "loaded": {
      "_": false
    },
    "content": {}
  };
  request = new XMLHttpRequest();
  request.open("GET", src, true);
  request.responseType = "arraybuffer";
  request.onload = function() {
    if (this.readyState === 4) {
      return environment.sound_context.decodeAudioData(this.response, (function(buffer) {
        result.loaded._ = true;
        return result.content._ = buffer;
      }), function() {});
    }
  };
  request.send();
  return result;
};

playSound = function(environment, buffer) {
  var source;
  source = environment.sound_context.createBufferSource();
  source.buffer = buffer;
  source.connect(environment.sound_context.destination);
  return source.start(0);
};

Environment = (function() {
  function Environment() {
    this.layers = [];
    this.layers[0] = $("#backLayer")[0].getContext("2d");
    this.layers[1] = $("#middleLayer")[0].getContext("2d");
    this.layers[2] = $("#frontLayer")[0].getContext("2d");
    this.width = this.layers[0].canvas.width;
    this.height = this.layers[0].canvas.height;
    this.loop = new MainMenuLoop(this);
    this.loading = true;
    this.constants = constants;
    this.keys = {};
    this.data = {
      pieces: pieces,
      attacks: attacks,
      players: players,
      stages: stages
    };
    this.sound_context = new AudioContext();
    document.onkeydown = (function(_this) {
      return function(event) {
        return _this.onKeyDown(event);
      };
    })(this);
    document.onkeyup = (function(_this) {
      return function(event) {
        return _this.onKeyUp(event);
      };
    })(this);
    document.onmousedown = (function(_this) {
      return function(event) {
        return _this.onMouseDown(event);
      };
    })(this);
    document.onmouseup = (function(_this) {
      return function(event) {
        return _this.onMouseUp(event);
      };
    })(this);
    document.onmousemove = (function(_this) {
      return function(event) {
        return _this.onMouseMove(event);
      };
    })(this);
    setTimeout(((function(_this) {
      return function() {
        return _this.tick();
      };
    })(this)), this.loop.frame_time);
  }

  Environment.prototype.drawSprite = function(img, rect, pos) {
    return this.layers[1].drawImage(img, rect.x, rect.y, rect.w, rect.h, pos.x, pos.y, rect.w, rect.h);
  };

  Environment.prototype.drawBackground = function(img, rect, pos) {
    return this.layers[0].drawImage(img, rect.x, rect.y, rect.w, rect.h, pos.x, pos.y, rect.w, rect.h);
  };

  Environment.prototype.drawForeground = function(img, rect, pos) {
    return this.layers[2].drawImage(img, rect.x, rect.y, rect.w, rect.h, pos.x, pos.y, rect.w, rect.h);
  };

  Environment.prototype.clean = function() {
    this.layers[0].clearRect(0, 0, this.width, this.height);
    this.layers[1].clearRect(0, 0, this.width, this.height);
    return this.layers[2].clearRect(0, 0, this.width, this.height);
  };

  Environment.prototype.clear = function(_arg) {
    var h, w, x, y;
    x = _arg.x, y = _arg.y, w = _arg.w, h = _arg.h;
    return this.layers[1].clearRect(x, y, w, h);
  };

  Environment.prototype.clearForeground = function(_arg) {
    var h, w, x, y;
    x = _arg.x, y = _arg.y, w = _arg.w, h = _arg.h;
    return this.layers[2].clearRect(x, y, w, h);
  };

  Environment.prototype.tick = function() {
    if (this.loading) {
      this.loading = !this.loop.isReady();
      return setTimeout(((function(_this) {
        return function() {
          return _this.tick();
        };
      })(this)), this.loop.frame_time);
    } else {
      this.loop.clear(this);
      this.loop.animate(this);
      this.loop.draw(this);
      return setTimeout(((function(_this) {
        return function() {
          return _this.tick();
        };
      })(this)), this.loop.frame_time);
    }
  };

  Environment.prototype.onKeyDown = function(event) {
    if (!this.loading) {
      this.keys[event.keyCode] = true;
      return this.loop.onKeyDown(event, this);
    }
  };

  Environment.prototype.onKeyUp = function(event) {
    if (!this.loading) {
      this.keys[event.keyCode] = false;
      return this.loop.onKeyUp(event, this);
    }
  };

  Environment.prototype.onMouseDown = function(event) {
    if (!this.loading) {
      return this.loop.onMouseDown(event, this);
    }
  };

  Environment.prototype.onMouseUp = function(event) {
    if (!this.loading) {
      return this.loop.onMouseUp(event, this);
    }
  };

  Environment.prototype.onMouseMove = function(event) {
    if (!this.loading) {
      return this.loop.onMouseMove(event, this);
    }
  };

  return Environment;

})();

Loop = (function() {
  var frame_time;

  function Loop(environment) {
    this.state = {};
  }

  Loop.prototype.isReady = function() {
    return true;
  };

  frame_time = 1000 / 32;

  Loop.prototype.clear = function(environment) {};

  Loop.prototype.animate = function(environment) {};

  Loop.prototype.draw = function(environment) {};

  Loop.prototype.onKeyDown = function(event, environment) {};

  Loop.prototype.onKeyUp = function(event, environment) {};

  Loop.prototype.onMouseDown = function(event, environment) {};

  Loop.prototype.onMouseUp = function(event, environment) {};

  Loop.prototype.onMouseMove = function(event, environment) {};

  return Loop;

})();

GameLoop = (function(_super) {
  __extends(GameLoop, _super);

  function GameLoop(environment, p1_def, p2_def, stage) {
    var _ref, _ref1, _ref2, _ref3;
    GameLoop.__super__.constructor.call(this, environment);
    environment.clean();
    this.state.dirty = true;
    this.state.scroll = 0;
    this.frame_time = 1000 / 32;
    _ref = loadPlayer(environment, p1_def, environment.constants.P1_INIT_POS, 1), this.l_p1 = _ref["loaded"], this.state.p1 = _ref["content"];
    _ref1 = loadPlayer(environment, p2_def, environment.constants.P2_INIT_POS, 0), this.l_p2 = _ref1["loaded"], this.state.p2 = _ref1["content"];
    _ref2 = loadStage(stage), this.l_stage = _ref2["loaded"], this.state.stage = _ref2["content"];
    _ref3 = loadImage("src/images/UI.png"), this.l_UI = _ref3["loaded"], this.UI_image = _ref3["content"];
    this.attacks = [];
  }

  GameLoop.prototype.isReady = function() {
    return this.l_p1._ && this.l_p2._ && this.l_stage._ && this.l_UI._;
  };

  GameLoop.prototype.animate = function(environment) {
    var attack, _i, _len, _ref;
    this.state.p1.animate(environment);
    this.state.p2.animate(environment);
    this.state.stage.animate(environment);
    _ref = this.attacks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      attack = _ref[_i];
      attack.animate(environment);
    }
    return this.attacks = this.attacks.filter(function(x) {
      return !x.is_finished;
    });
  };

  GameLoop.prototype.draw = function(environment) {
    var attack, _i, _len, _ref;
    this.state.p1.draw(environment);
    this.state.p2.draw(environment);
    _ref = this.attacks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      attack = _ref[_i];
      attack.draw(environment);
    }
    this.state.stage.draw(environment);
    return this.drawUI(environment);
  };

  GameLoop.prototype.clear = function(environment) {
    var attack, _i, _len, _ref;
    _ref = this.attacks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      attack = _ref[_i];
      attack.clear(environment);
    }
    this.state.p1.clear(environment);
    return this.state.p2.clear(environment);
  };

  GameLoop.prototype.drawUI = function(environment) {
    var mult, showing;
    environment.clearForeground(environment.constants.UI_RECT);
    mult = this.state.p1.hit_points / this.state.p1.max_hit_points;
    if (!(mult <= 0)) {
      showing = {
        "x": 0,
        "y": 0,
        "w": 200 * mult,
        "h": 20
      };
      environment.drawForeground(this.UI_image, showing, {
        "x": 10,
        "y": 10
      });
    }
    mult = this.state.p2.hit_points / this.state.p2.max_hit_points;
    if (!(mult <= 0)) {
      showing = {
        "x": 200 * (1 - mult),
        0: 0,
        "y": 20,
        "w": 200 * mult,
        "h": 20
      };
      return environment.drawForeground(this.UI_image, showing, {
        "x": 260 + 200 * (1 - mult),
        "y": 10
      });
    }
  };

  return GameLoop;

})(Loop);

MainMenuLoop = (function(_super) {
  __extends(MainMenuLoop, _super);

  function MainMenuLoop(environment) {
    var _ref, _ref1, _ref2;
    MainMenuLoop.__super__.constructor.call(this, environment);
    environment.clean();
    this.state.selected = 0;
    this.state.previous = 0;
    this.state.dirty = true;
    this.frame_time = 1000 / 16;
    _ref = loadImage("src/images/main_menu_background.png"), this.l_background = _ref["loaded"], this.background = _ref["content"];
    _ref1 = loadImage("src/images/main_menu_buttons.png"), this.l_buttons = _ref1["loaded"], this.buttons = _ref1["content"];
    _ref2 = loadImage("src/images/main_menu_sel_buttons.png"), this.l_sel_buttons = _ref2["loaded"], this.sel_buttons = _ref2["content"];
  }

  MainMenuLoop.prototype.isReady = function() {
    return this.l_background._ & this.l_buttons._ & this.l_sel_buttons._;
  };

  MainMenuLoop.prototype.draw = function(environment) {
    var pos, rect;
    if (this.state.dirty) {
      rect = {
        "x": 0,
        "y": 0,
        "w": environment.width,
        "h": environment.height
      };
      pos = {
        "x": 0,
        "y": 0
      };
      environment.drawBackground(this.background, rect, pos);
      rect = {
        "x": 0,
        "y": 0,
        "w": environment.constants.MENU_BUTTONS_WIDTH,
        "h": environment.constants.MENU_BUTTONS_HEIGHT
      };
      pos = {
        "x": environment.constants.MENU_BUTTONS_POS.x,
        "y": environment.constants.MENU_BUTTONS_POS.y
      };
      environment.drawBackground(this.buttons, rect, pos);
      rect = this.calculateButtonSprite(environment);
      pos = this.calculateButtonPos(environment);
      environment.drawSprite(this.sel_buttons, rect, pos);
      this.state.dirty = false;
    }
    if (this.state.selected !== this.state.previous) {
      rect = this.calculateClearArea(environment);
      environment.clear(rect);
      rect = this.calculateButtonSprite(environment);
      pos = this.calculateButtonPos(environment);
      return environment.drawSprite(this.sel_buttons, rect, pos);
    }
  };

  MainMenuLoop.prototype.calculateButtonSprite = function(environment) {
    var height, width, x, y;
    x = 0;
    y = this.state.selected * environment.constants.MENU_BUTTON_HEIGHT;
    width = environment.constants.MENU_BUTTONS_WIDTH;
    height = environment.constants.MENU_BUTTON_HEIGHT;
    return {
      "x": x,
      "y": y,
      "w": width,
      "h": height
    };
  };

  MainMenuLoop.prototype.calculateButtonPos = function(environment) {
    var x, y;
    x = environment.constants.MENU_BUTTONS_POS.x;
    y = environment.constants.MENU_BUTTONS_POS.y + environment.constants.MENU_BUTTON_HEIGHT * this.state.selected;
    return {
      "x": x,
      "y": y
    };
  };

  MainMenuLoop.prototype.calculateClearArea = function(environment) {
    var height, width, x, y;
    x = environment.constants.MENU_BUTTONS_POS.x;
    y = environment.constants.MENU_BUTTONS_POS.y + environment.constants.MENU_BUTTON_HEIGHT * this.state.previous;
    width = environment.constants.MENU_BUTTONS_WIDTH;
    height = environment.constants.MENU_BUTTON_HEIGHT;
    return {
      "x": x,
      "y": y,
      "w": width,
      "h": height
    };
  };

  MainMenuLoop.prototype.onKeyUp = function(event, environment) {
    switch (event.keyCode) {
      case environment.constants.KEY_UP:
        this.state.previous = this.state.selected;
        return this.state.selected = __modulo(this.state.selected - 1, environment.constants.MENU_NUM_ELEM);
      case environment.constants.KEY_DOWN:
        this.state.previous = this.state.selected;
        return this.state.selected = (this.state.selected + 1) % environment.constants.MENU_NUM_ELEM;
      case environment.constants.KEY_ENTER:
        switch (this.state.selected) {
          case 0:
            environment.loop = new GameLoop(environment, environment.data.players[0], environment.data.players[0], environment.data.stages[0]);
            return environment.loading = true;
        }
    }
  };

  return MainMenuLoop;

})(Loop);

Player = (function() {
  function Player(environment, def, pos, human) {
    var movement_multiplier, _ref;
    this.pos = pos;
    this.legs = new Piece(pos, environment.data.pieces[def.legs]);
    this.body = new Piece(pos, environment.data.pieces[def.body]);
    this.head = new Piece(pos, environment.data.pieces[def.head]);
    this.arms = new Piece(pos, environment.data.pieces[def.arms]);
    _ref = loadSound(environment, "src/sound/jump_001.ogg"), this.l_jump_sound = _ref["loaded"], this.jump_sound = _ref["content"];
    this.max_weight = this.legs.attributes.max_weight;
    this.weight = this.legs.attributes.weight + this.body.attributes.weight + this.head.attributes.weight + this.arms.attributes.weight;
    this.state = {
      "crouch": false,
      "jump": false,
      "defend": false,
      "attack": false
    };
    this.s_power = this.head.attributes.special_power;
    this.a_power = this.arms.attributes.power;
    this.l_power = this.legs.attributes.power;
    this.defense = this.body.attributes.defense;
    this.s_defense = this.body.attributes.special_defense;
    this.a_defense = this.arms.attributes.defense;
    this.max_hit_points = this.body.attributes.hit_points;
    this.hit_points = this.body.attributes.hit_points;
    movement_multiplier = this.calculateMovementMultiplier();
    this.movement = Math.round(this.legs.attributes.movement * movement_multiplier);
    this.jump_strength = this.legs.attributes.jump * movement_multiplier;
    this.y_speed = 0;
    this.bounding_rect = this.getBoundingRect();
    if (human === 1) {
      this.animation_behaviour = animateAsP1;
    } else if (human === 2) {
      this.animation_behaviour = animateAsP2;
    } else {
      this.animation_behaviour = animateAsCPU;
    }
    this.attacks = AttackDefinition.loadAttacks(environment, def.attacks);
    this.attack_info = {};
    this.frame = 0;
    this.direction = 0;
  }

  Player.prototype.isReady = function() {
    return this.legs.isReady() & this.body.isReady() & this.head.isReady() & this.arms.isReady() & this.l_jump_sound._;
  };

  Player.prototype.getBoundingRect = function() {
    var x, x2, x_max, x_min, y, y2, y_max, y_min;
    x = this.legs.pos.x;
    x2 = this.legs.pos.x + this.legs.dimensions[this.legs.current_sprite].w;
    y = this.legs.pos.y;
    y2 = this.legs.pos.y + this.legs.dimensions[this.legs.current_sprite].h;
    x_min = x;
    x_max = x2;
    y_min = y;
    y_max = y2;
    x = this.body.pos.x;
    x2 = this.body.pos.x + this.body.dimensions[this.body.current_sprite].w;
    y = this.body.pos.y;
    y2 = this.body.pos.y + this.body.dimensions[this.body.current_sprite].h;
    x_min = Math.min(x_min, x);
    x_max = Math.max(x_max, x2);
    y_min = Math.min(y_min, y);
    y_max = Math.max(y_max, y2);
    x = this.head.pos.x;
    x2 = this.head.pos.x + this.head.dimensions[this.head.current_sprite].w;
    y = this.head.pos.y;
    y2 = this.head.pos.y + this.head.dimensions[this.head.current_sprite].h;
    x_min = Math.min(x_min, x);
    x_max = Math.max(x_max, x2);
    y_min = Math.min(y_min, y);
    y_max = Math.max(y_max, y2);
    x = this.arms.pos.x;
    x2 = this.arms.pos.x + this.arms.dimensions[this.arms.current_sprite].w;
    y = this.arms.pos.y;
    y2 = this.arms.pos.y + this.arms.dimensions[this.arms.current_sprite].h;
    x_min = Math.min(x_min, x);
    x_max = Math.max(x_max, x2);
    y_min = Math.min(y_min, y);
    y_max = Math.max(y_max, y2);
    return {
      "x": x_min,
      "y": y_min,
      "w": x_max - x_min,
      "h": y_max - y_min
    };
  };

  Player.prototype.clear = function(environment) {
    return environment.clear(this.bounding_rect);
  };

  Player.prototype.draw = function(environment) {
    var arms_base_point, arms_point, base, body_base_points, body_point, head_base_point, head_point, legs_base_point, legs_point, scroll;
    scroll = environment.loop.state.scroll;
    base = environment.loop.state.stage.base_line;
    legs_point = {};
    legs_point.x = this.pos.x - scroll - this.legs.dimensions[this.legs.current_sprite].w / 2;
    legs_point.y = base - this.pos.y - this.legs.dimensions[this.legs.current_sprite].h;
    this.legs.pos = legs_point;
    body_point = {};
    legs_base_point = this.legs.getBasePoint();
    body_base_points = this.body.getBasePoint();
    head_base_point = this.head.getBasePoint();
    arms_base_point = this.arms.getBasePoint();
    body_point.x = legs_point.x + legs_base_point.x - body_base_points[0].x;
    body_point.y = legs_point.y + legs_base_point.y - body_base_points[0].y;
    this.body.pos = body_point;
    head_point = {};
    head_point.x = body_point.x + body_base_points[1].x - head_base_point.x;
    head_point.y = body_point.y + body_base_points[1].y - head_base_point.y;
    this.head.pos = head_point;
    arms_point = {};
    arms_point.x = body_point.x + body_base_points[2].x - arms_base_point.x;
    arms_point.y = body_point.y + body_base_points[2].y - arms_base_point.y;
    this.arms.pos = arms_point;
    this.head.draw(environment);
    this.body.draw(environment);
    this.arms.draw(environment);
    this.legs.draw(environment);
    return this.bounding_rect = this.getBoundingRect();
  };

  Player.prototype.animate = function(environment) {
    this.frame += 1;
    this.animation_behaviour(environment, this);
    if (this.state.jump) {
      this.pos.y += Math.floor(this.y_speed);
      this.y_speed -= environment.constants.GRAVITY;
      if (this.pos.y < 0) {
        this.pos.y = 0;
        this.y_speed = 0;
        this.state.jump = false;
      }
    }
    if (this.state.attack) {
      if (!this.attack_info.attack_started & this.attack_info.attack_holder.current_state === this.attack_info.start_frame) {
        environment.loop.attacks.push(new Attack(this.getAttackPos(), this.attacks[this.attack_info.type], this.attack_info.base_power, this.s_power, this));
        this.attack_info.attack_started = true;
      }
      if (this.frame > this.attack_info.last_frame) {
        this.frame = 0;
        this.state.attack = false;
      }
    }
    this.legs.animate(this, environment);
    this.body.animate(this, environment);
    this.head.animate(this, environment);
    return this.arms.animate(this, environment);
  };

  Player.prototype.getAttackPos = function() {
    var attack_offset, base, holder_offset;
    base = this.attack_info.attack_holder.pos;
    holder_offset = this.attack_info.attack_holder.attributes.attack_base_points[this.attack_info.current_sprite - this.attack_info.offset][this.direction];
    attack_offset = this.attacks[this.attack_info.type].base_points[0][this.direction];
    return {
      "x": base.x + holder_offset.x - attack_offset.x,
      "y": base.y + holder_offset.y - attack_offset.y
    };
  };

  Player.prototype.calculateMovementMultiplier = function() {
    var rate;
    rate = this.weight / this.max_weight;
    if (rate < 0) {
      return 1.5;
    } else if (rate < 0.5) {
      return 1;
    } else if (rate < 0.75) {
      return 0.75;
    } else if (rate < 0.90) {
      return 0.50;
    } else if (rate < 1) {
      return 0.25;
    } else {
      return 0;
    }
  };

  Player.prototype.canMove = function() {
    return !this.state.crouch & !this.state.defend & (!this.state.attack || this.state.jump);
  };

  Player.prototype.canJump = function() {
    return !this.state.crouch & !this.state.jump & !this.state.defend & !this.state.attack;
  };

  Player.prototype.canCrouch = function() {
    return !this.state.jump & !this.state.attack;
  };

  Player.prototype.canDefend = function() {
    return !this.state.attack;
  };

  Player.prototype.canAttack = function() {
    return !this.state.attack & !this.state.defend;
  };

  Player.prototype.move = function(environment, direction) {
    this.pos.x += this.movement * direction;
    this.pos.x = Math.max(environment.constants.LIMIT_LEFT, this.pos.x);
    this.pos.x = Math.min(environment.loop.state.stage.width - environment.constants.LIMIT_RIGHT, this.pos.x);
    this.direction = direction === -1 ? 1 : 0;
    this.legs.direction = this.direction;
    this.head.direction = this.direction;
    this.arms.direction = this.direction;
    return this.body.direction = this.direction;
  };

  Player.prototype.jump = function(environment) {
    this.y_speed = this.jump_strength;
    this.state.jump = true;
    return playSound(environment, this.jump_sound._);
  };

  Player.prototype.attack = function(type) {
    this.attack_info = {};
    this.attack_info.type = type;
    this.attack_info.current_sprite = (function() {
      switch (false) {
        case type !== "high_punch":
          return 4;
        case type !== "medium_punch":
          return 5;
        case type !== "special_punch_1":
          return 6;
        case type !== "special_punch_2":
          return 7;
        case type !== "medium_kick":
          return 8;
        case type !== "low_kick":
          return 9;
        case type !== "special_kick_1":
          return 10;
        case type !== "special_kick_2":
          return 11;
      }
    })();
    this.attack_info.attack_holder = this.attack_info.current_sprite <= 7 ? this.arms : this.legs;
    this.attack_info.offset = this.attack_info.current_sprite <= 7 ? 4 : 8;
    this.attack_info.base_power = this.attack_info.current_sprite <= 7 ? this.a_power : this.l_power;
    this.attack_info.attack_started = false;
    this.attack_info.last_frame = this.attack_info.attack_holder.frame_per_animation[this.attack_info.current_sprite] * 10;
    this.attack_info.start_frame = this.attack_info.attack_holder.attributes.attack_start_frame[this.attack_info.current_sprite - this.attack_info.offset];
    this.state.attack = true;
    return this.frame = 0;
  };

  Player.prototype.receiveDamage = function(environment, dealt_damage, type) {
    dealt_damage -= (function() {
      switch (false) {
        case type !== "normal":
          return this.defense;
        case type !== "special":
          return this.s_defense;
        case type !== "mixed":
          return (this.defense + this.s_defense) / 2;
      }
    }).call(this);
    dealt_damage -= this.state.defend ? this.a_defense : 0;
    dealt_damage = Math.max(0, dealt_damage);
    this.hit_points -= dealt_damage;
    return this.hit_points = Math.max(0, this.hit_points);
  };

  return Player;

})();

loadPlayer = function(environment, def, pos, human) {
  var check, result;
  result = {
    "loaded": {
      "_": false
    },
    "content": new Player(environment, def, pos, human)
  };
  check = function(result) {
    if (result.content.isReady()) {
      return result.loaded._ = true;
    } else {
      return setTimeout((function() {
        return check(result);
      }), 100);
    }
  };
  check(result);
  return result;
};

animateAsP1 = function(environment, player) {
  if (environment.keys[environment.constants.BUTTON_HIGH_PUNCH] && player.canAttack()) {
    player.attack("high_punch");
  }
  if (environment.keys[environment.constants.KEY_LEFT] && player.canMove()) {
    player.move(environment, -1);
  }
  if (environment.keys[environment.constants.KEY_RIGHT] && player.canMove()) {
    player.move(environment, +1);
  }
  if (environment.keys[environment.constants.KEY_UP] && player.canJump()) {
    player.jump(environment);
  }
  if (environment.keys[environment.constants.KEY_DOWN] && player.canCrouch()) {
    player.state.crouch = true;
  } else {
    player.state.crouch = false;
  }
  if (environment.keys[environment.constants.BUTTON_BLOCK] && player.canDefend()) {
    return player.state.defend = true;
  } else {
    return player.state.defend = false;
  }
};

animateAsCPU = function(environment, player) {
  var foe, _ref, _ref1, _ref2;
  foe = environment.loop.state.p1 === player ? environment.loop.state.p2 : environment.loop.state.p1;
  if (foe.state.jump & player.canCrouch()) {
    return player.state.crouch = true;
  } else if (foe.state.crouch & player.canJump()) {
    return player.jump(environment);
  } else if ((0 < (_ref = Math.abs(foe.pos.x - player.pos.x)) && _ref < 30) & player.canDefend()) {
    return player.state.defend = true;
  } else if ((0 < (_ref1 = foe.pos.x - player.pos.x) && _ref1 < 60) & player.canMove()) {
    return player.move(environment, -1);
  } else if ((0 > (_ref2 = foe.pos.x - player.pos.x) && _ref2 > -60) & player.canMove()) {
    return player.move(environment, +1);
  } else if ((foe.pos.x - player.pos.x) >= 80) {
    player.state.crouch = false;
    player.state.defend = false;
    return player.move(environment, +1);
  } else if ((foe.pos.x - player.pos.x) <= -80) {
    player.state.crouch = false;
    player.state.defend = false;
    return player.move(environment, -1);
  }
};

Stage = (function() {
  function Stage(def) {
    var _ref, _ref1;
    _ref = loadImage(def.background_img), this.l_background = _ref["loaded"], this.background = _ref["content"];
    _ref1 = loadImage(def.foreground_img), this.l_foreground = _ref1["loaded"], this.foreground = _ref1["content"];
    this.background_height = def.background_height, this.background_frames = def.background_frames, this.foreground_height = def.foreground_height, this.foreground_frames = def.foreground_frames, this.foreground_loc = def.foreground_loc, this.base_line = def.base_line, this.width = def.width;
    this.dirty = true;
    this.background_using_frame = 0;
    this.foreground_using_frame = 0;
    this.frame = 0;
  }

  Stage.prototype.isReady = function() {
    return this.l_background._ & this.l_foreground._;
  };

  Stage.prototype.animate = function(environment) {
    this.frame += 1;
    if ((this.frame % 10) === 0) {
      this.foreground_using_frame = (this.foreground_using_frame + 1) % this.foreground_frames;
      this.background_using_frame = (this.background_using_frame + 1) % this.background_frames;
      return this.dirty = true;
    }
  };

  Stage.prototype.draw = function(environment) {
    var clearRect, pos, rect;
    if (this.dirty) {
      rect = {
        "x": environment.loop.state.scroll,
        "y": this.background_using_frame * this.background_height,
        "w": environment.width,
        "h": this.background_height
      };
      pos = {
        "x": 0,
        "y": 0
      };
      environment.drawBackground(this.background, rect, pos);
      clearRect = {
        "x": 0,
        "y": this.foreground_loc,
        "w": environment.width,
        "h": this.foreground_height
      };
      rect = {
        "x": environment.loop.state.scroll,
        "y": this.foreground_using_frame * this.foreground_height,
        "w": environment.width,
        "h": this.foreground_height
      };
      pos = {
        "x": 0,
        "y": this.foreground_loc
      };
      environment.clearForeground(clearRect);
      environment.drawForeground(this.foreground, rect, pos);
      return this.dirty = false;
    }
  };

  return Stage;

})();

loadStage = function(def) {
  var check, result;
  result = {
    "loaded": {
      "_": false
    },
    "content": new Stage(def)
  };
  check = function(result) {
    if (result.content.isReady()) {
      return result.loaded._ = true;
    } else {
      return setTimeout((function() {
        return check(result);
      }), 100);
    }
  };
  check(result);
  return result;
};

Sprite = (function() {
  function Sprite(pos, definition) {
    var acum, aux, dimension, _ref;
    this.pos = pos;
    _ref = loadImage(definition.image), this.l_image = _ref["loaded"], this.image = _ref["content"];
    this.dimensions = definition.dimensions;
    this.frame_per_animation = definition.frames;
    acum = 0;
    this.sprite_start = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = this.dimensions;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        dimension = _ref1[_i];
        aux = acum;
        acum += dimension.h;
        _results.push(aux);
      }
      return _results;
    }).call(this);
    this.frame = 0;
    this.current_sprite = 0;
    this.current_state = 0;
    this.direction = 0;
  }

  Sprite.prototype.isReady = function() {
    return this.l_image._;
  };

  Sprite.prototype.getShowingRect = function() {
    var dim, x, y;
    dim = this.dimensions[this.current_sprite];
    x = (this.direction * this.image.width / 2) + (dim.w * this.current_state);
    y = this.sprite_start[this.current_sprite];
    return {
      "x": x,
      "y": y,
      "w": dim.w,
      "h": dim.h
    };
  };

  Sprite.prototype.animate = function(environment) {
    this.frame += 1;
    if ((this.frame % 10) === 0) {
      return this.current_state = (this.current_state + 1) % this.frame_per_animation[this.current_sprite];
    }
  };

  Sprite.prototype.draw = function(environment) {
    var rect;
    rect = this.getShowingRect();
    return environment.drawSprite(this.image, rect, this.pos);
  };

  Sprite.prototype.clear = function(environment) {
    var dim, rect;
    dim = this.dimensions[this.current_sprite];
    rect = {
      "x": this.pos.x,
      "y": this.pos.y,
      "w": dim.w,
      "h": dim.h
    };
    return environment.clear(rect);
  };

  Sprite.prototype.getRect = function() {
    return {
      "x": this.pos.x,
      "y": this.pos.y,
      "w": this.dimensions[this.current_sprite].w,
      "h": this.dimensions[this.current_sprite].h
    };
  };

  return Sprite;

})();

Piece = (function(_super) {
  __extends(Piece, _super);

  function Piece(pos, definition) {
    Piece.__super__.constructor.call(this, pos, definition);
    this.attributes = definition.attributes;
  }

  Piece.prototype.animate = function(player, environment) {
    this.updateCurrentSprite(player.state, player.attack_info);
    return Piece.__super__.animate.call(this, environment);
  };

  Piece.prototype.getBasePoint = function() {
    if (this.attributes.base_points) {
      return this.attributes.base_points[this.current_sprite][this.direction];
    } else {
      return [this.attributes.legs_points[this.current_sprite][this.direction], this.attributes.head_points[this.current_sprite][this.direction], this.attributes.arms_points[this.current_sprite][this.direction]];
    }
  };

  Piece.prototype.updateCurrentSprite = function(player_state, attack_info) {
    if (!player_state.defend) {
      if (!player_state.attack) {
        if (player_state.crouch && this.current_sprite !== 1) {
          this.current_sprite = 1;
          return this.current_state = 0;
        } else if (player_state.jump && this.current_sprite !== 2) {
          this.current_sprite = 2;
          return this.current_state = 0;
        } else if (!player_state.crouch && !player_state.jump && this.current_sprite !== 0) {
          this.current_sprite = 0;
          return this.current_state = 0;
        }
      } else {
        if (player_state.crouch && this.current_sprite !== 1) {
          this.current_sprite = 1;
          return this.current_state = 0;
        } else if (player_state.jump && this.current_sprite !== 2) {
          this.current_sprite = 2;
          return this.current_state = 0;
        } else if (!player_state.crouch && !player_state.jump && this.current_sprite !== attack_info.current_sprite) {
          this.current_sprite = attack_info.current_sprite;
          return this.current_state = 0;
        }
      }
    } else if (player_state.crouch && this.current_sprite !== 3) {
      this.current_sprite = 3;
      return this.current_state = 0;
    } else if (player_state.jump && this.current_sprite !== 3) {
      this.current_sprite = 3;
      return this.current_state = 0;
    } else if (!player_state.crouch && !player_state.jump && this.current_sprite !== 3) {
      this.current_sprite = 3;
      return this.current_state = 0;
    }
  };

  return Piece;

})(Sprite);

AttackDefinition = (function(_super) {
  __extends(AttackDefinition, _super);

  function AttackDefinition(definition) {
    AttackDefinition.__super__.constructor.call(this, {
      "x": 0,
      "y": 0
    }, definition);
    this.base_points = definition.base_points;
    this.type = definition.type;
    this.multiplier = definition.multiplier;
  }

  AttackDefinition.loadAttacks = function(environment, definition) {
    var key, result, value;
    result = {};
    for (key in definition) {
      value = definition[key];
      result[key] = new AttackDefinition(environment.data.attacks[value]);
    }
    return result;
  };

  return AttackDefinition;

})(Sprite);

Attack = (function(_super) {
  __extends(Attack, _super);

  function Attack(pos, definition, power, s_power, owner) {
    var acum;
    this.pos = pos;
    this.owner = owner;
    this.l_image = true;
    this.image = definition.image;
    this.dimensions = definition.dimensions;
    this.frame_per_animation = definition.frame_per_animation;
    acum = 0;
    this.sprite_start = definition.sprite_start;
    this.frame = 0;
    this.current_sprite = 0;
    this.current_state = 0;
    this.direction = this.owner.direction;
    this.base_points = definition.base_points;
    this.type = definition.type;
    this.power = (function() {
      switch (false) {
        case this.type !== "normal":
          return power;
        case this.type !== "special":
          return s_power;
        case this.type !== "mixed":
          return (power + s_power) / 2;
        default:
          throw "Unrecognized attack type.";
      }
    }).call(this);
    this.power = this.power * definition.multiplier;
    this.no_draw = false;
    this.is_finished = false;
  }

  Attack.prototype.animate = function(environment) {
    Attack.attack_behaviours.straight(this, environment);
    this.frame += 1;
    if ((this.frame % 10) === 0) {
      this.current_state += 1;
    }
    if (this.current_state >= this.frame_per_animation[this.current_sprite]) {
      this.current_sprite += 1;
      this.current_state = 0;
    }
    if (this.current_sprite >= this.frame_per_animation.length) {
      this.no_draw = true;
    }
    if (!this.no_draw) {
      return this.checkCollision(environment);
    }
  };

  Attack.prototype.draw = function(environment) {
    if (!this.no_draw) {
      return Attack.__super__.draw.call(this, environment);
    }
  };

  Attack.prototype.clear = function(environment) {
    if (this.no_draw) {
      return this.is_finished = true;
    } else {
      return Attack.__super__.clear.call(this, environment);
    }
  };

  Attack.prototype.checkCollision = function(environment) {
    var foe, thisRect;
    foe = environment.loop.state.p1 === this.owner ? environment.loop.state.p2 : environment.loop.state.p1;
    thisRect = this.getRect();
    if (rectCollide(thisRect, foe.bounding_rect)) {
      if (rectCollide(thisRect, foe.legs.getRect()) || rectCollide(thisRect, foe.body.getRect()) || rectCollide(thisRect, foe.head.getRect()) || rectCollide(thisRect, foe.arms.getRect())) {
        this.no_draw = true;
        return foe.receiveDamage(environment, this.power, this.type);
      }
    }
  };

  Attack.attack_behaviours = {
    "static": function(attack, environment) {},
    "straight": function(attack, environment) {
      attack.pos.x += attack.direction === 0 ? 1 : -1;
      if (attack.pos.x > environment.loop.state.stage.width) {
        return attack.no_draw = true;
      }
    }
  };

  return Attack;

})(Sprite);

rectCollide = function(_arg, _arg1) {
  var h1, h2, w1, w2, x, x1, x2, y, y1, y2;
  x1 = _arg["x"], y1 = _arg["y"], w1 = _arg["w"], h1 = _arg["h"];
  x2 = _arg1["x"], y2 = _arg1["y"], w2 = _arg1["w"], h2 = _arg1["h"];
  x = ((x1 <= x2 && x2 <= x1 + w1)) || ((x2 <= x1 && x1 <= x2 + w2));
  y = ((y1 <= y2 && y2 <= y1 + h1)) || ((y2 <= y1 && y1 <= y2 + h2));
  return x && y;
};

loadImage = function(src) {
  var result;
  result = {
    "loaded": {
      "_": false
    },
    "content": new Image
  };
  result.content.onload = function() {
    return result.loaded._ = true;
  };
  result.content.src = src;
  return result;
};
